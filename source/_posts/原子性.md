---
title: 原子性
date: 2021-07-15 21:37:48
tags: [java]
categories: java
---

# 原子性

> 参考文章地址：
> http://www.blogjava.net/xylz/archive/2010/07/03/325168.html
> 

## 在 Java concurrency in Practic 中是这样定义线程安全的：
当多个线程访问一个类时，如果不用考虑这些线程在运行时环境下的调度和交替运行，并且不需要额外的同步及在调度方面代码不必做其他的协调，这个类仍然是正确的，那么这个类是线程安全的。

显然只有资源竞争才会导致线程不安全，因此**无状态对象永远是线程安全的**。

原子操作的描述是：**多个线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤**，那么这个操作就是原子的。

## volatile 语义
volatile 相当于 synchronized 的弱实现，也就是 volatile 实现了 synchronized 的语义，却没有锁的机制，它确保对 volatile 字段的更新以可以预见的方式告知其他的线程。

volatile 包含以下语义：
* Java 储存模型不会对 volatile 指令的操作进行排序：这个保证对 volatile 变量的操作时按照指令的出现顺序执行的。
* volatile 变量不会被缓存在寄存器中（只有拥有的线程可见）或其他对 cpu 不可见的地方，每次总是从主存中读取 volatile 变量的结果。也就是说对于 volatile 变量的修改，其他线程总是可见的，并且不是使用自己线程内部变量。也就是在 happens-before 法则中，对一个 volatile 变量的写操作，其后的任何读操作理解可见此操作的结果。

尽管 volatile 变量的特性不错，但是 volatile 并不能保证线程安全，也就是 volatile 不是原则性的，volatile 变量只能保证可见性（一个线程修改后其它线程能够理解看到此变化后的结果），

应用 volatile 变量的三个原则：
* 写入变量不依赖此变量的值，或者只有一个线程修改此变量
* 变量的状态不需要与其它变量共同参与不变约束
* 访问变量不需要加锁